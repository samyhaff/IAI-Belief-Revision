Index: agent.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from sympy import symbols, And, Or, Not\nfrom sympy.logic.boolalg import to_int_repr, to_cnf\nfrom itertools import chain, combinations\n\n\nclass Agent:\n    def __init__(self):\n        self.knowledge_base = set()\n\n    def tell(self, sentence):\n        #print('Adding', sentence, 'as', to_cnf(sentence))\n        #self.knowledge_base.add(to_cnf(sentence))\n        print('Adding', sentence)\n        self.knowledge_base.add(sentence)\n        print('New knowledge base:', self.knowledge_base)\n\n    def ask(self, query):\n        return self.resolution(query)\n\n    def resolve(self, clause1, clause2):\n        resolvents = set()\n        for literal1 in clause1:\n            for literal2 in clause2:\n                if literal1 == -literal2:\n                    new_clause = clause1.union(clause2) - {literal1, literal2}\n                    resolvents.add(frozenset(new_clause))\n        return resolvents\n\n    def resolution(self, query, knowledge_base=None):\n        if knowledge_base is None:\n            cnf = to_cnf(And(*self.knowledge_base, Not(query)))\n        else:\n            cnf = to_cnf(And(*knowledge_base, Not(query)))\n        clauses = to_int_repr(cnf.args, cnf.free_symbols)\n        clauses = set([frozenset(x) for x in clauses])\n        new_clauses = set()\n        while True:\n            for clause1 in clauses:\n                for clause2 in clauses:\n                    resolvents = self.resolve(clause1, clause2)\n                    if set() in resolvents:\n                        return True\n                    new_clauses |= resolvents\n            if new_clauses.issubset(clauses):\n                return False\n            clauses |= new_clauses\n\n    def entailment(self, knowledge_base, query):\n        return self.resolution(query=query, knowledge_base=knowledge_base)\n\n    def remainders(self, set_a, phi):\n        set_a = to_cnf(And(*set_a))\n        #set_a_list = to_int_repr(set_a.args, set_a.free_symbols)\n        set_a_list = set_a.args\n        set_a_subsets = list(chain.from_iterable(combinations(set_a_list, r) for r in range(1, len(set_a_list))))\n        set_a_subsets.sort(key=len, reverse=True)\n\n        remainders = list()\n        for set_a_subset in set_a_subsets:\n            set_a_subset = frozenset(set_a_subset)\n            if not self.entailment(set_a_subset, phi) and not any([set_a_subset.issubset(r) for r in remainders]):\n                remainders.append(set_a_subset)\n\n        #for remainder in remainders:\n        #    if not any([remainder.issubset(r) for r in remainders if r != remainder]):\n        #        remainders.remove(remainder)\n\n        return remainders\n\n\n    def partial_meet_contraction(self, query):\n        print('Contracting', self.knowledge_base, 'with', query)\n        remainders = self.remainders(set_a=self.knowledge_base, phi=query)\n        # self.knowledge_base = set.intersection(*[set(fs) for fs in remainders]) # doesn't always work\n        self.knowledge_base = set(remainders[0]) # testing purposes\n        print('New knowledge base:', self.knowledge_base)\n        print()\n\n    def partial_meet_contraction_samy(self, query):\n        print('SAMYs METHOD: Contracting', self.knowledge_base, 'with', query)\n        new_knowledge_base = set()\n        clauses = to_cnf(And(*self.knowledge_base)).args\n        for clause in clauses:\n            clause_set = set()\n            clause_set.add(clause)\n            if not self.entailment(clause_set, query):\n                new_knowledge_base.add(clause)\n        self.knowledge_base = new_knowledge_base\n        print('New knowledge base:', self.knowledge_base)\n        print()\n\n    def revision(self, query):\n        self.partial_meet_contraction(Not(query))\n        self.tell(query)\n\n\n# tests\nagent = Agent()\nA, B, C = symbols('A B C')\nagent.tell(And(A, B))\nagent.tell(Or(A, B))\nprint('Does', agent.knowledge_base, 'entails', B, '?', agent.ask(B))\nprint('Does', agent.knowledge_base, 'entails', C, '?', agent.ask(C))\nagent.partial_meet_contraction(B)\n\n\nagent = Agent()\nA, B, C = symbols('A B C')\nagent.tell(And(A, B))\nagent.tell(Or(A, B))\nagent.partial_meet_contraction_samy(B)\n# print(agent.knowledge_base)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/agent.py b/agent.py
--- a/agent.py	(revision 1d9369a37b4b63d418e58daaf7f9eb68ea6e9f44)
+++ b/agent.py	(date 1682762434166)
@@ -1,17 +1,18 @@
 from sympy import symbols, And, Or, Not
 from sympy.logic.boolalg import to_int_repr, to_cnf
 from itertools import chain, combinations
+import copy
 
 
 class Agent:
     def __init__(self):
-        self.knowledge_base = set()
+        self.knowledge_base = list()
 
     def tell(self, sentence):
         #print('Adding', sentence, 'as', to_cnf(sentence))
         #self.knowledge_base.add(to_cnf(sentence))
         print('Adding', sentence)
-        self.knowledge_base.add(sentence)
+        self.knowledge_base.append(sentence)
         print('New knowledge base:', self.knowledge_base)
 
     def ask(self, query):
@@ -50,8 +51,12 @@
 
     def remainders(self, set_a, phi):
         set_a = to_cnf(And(*set_a))
-        #set_a_list = to_int_repr(set_a.args, set_a.free_symbols)
         set_a_list = set_a.args
+
+        remainders = copy.deepcopy(set_a)
+
+        while not remainders.
+
         set_a_subsets = list(chain.from_iterable(combinations(set_a_list, r) for r in range(1, len(set_a_list))))
         set_a_subsets.sort(key=len, reverse=True)
 
